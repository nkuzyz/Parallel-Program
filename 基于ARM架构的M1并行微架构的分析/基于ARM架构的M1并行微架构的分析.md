## 指令集架构



指令集架构（英语：Instruction Set Architecture，缩写为ISA），又称指令集或指令集体系，是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外[I/O。指令集架构包含一系列的opcode即操作码（机器语言），以及由特定处理器执行的基本命令。

在计算机中，指示计算机硬件执行某种运算、处理功能的命令称为指令。指令是计算机运行的最小的功能单位，而硬件的作用是完成每条指令规定的功能。一台计算机上全部指令的集合，就是这台计算机的指令系统。指令系统也称指令集，是这台计算机全部功能的体现。^[1]^ 从现阶段的主流体系结构来讲，指令集可分为复杂指令集（CISC）与精简指令集（RISC）。

目前市场上四大主流指令集为X86、MIPS、ARM、RISC-V。下图源于OFweek电子工程网整理自公开资料，其中详细指出了各个主流指令集的运营者，特点与代表生产商。

![8601a18b87d6277f05715bf45537bd38e824fcb7.jpeg@f_auto](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/8601a18b87d6277f05715bf45537bd38e824fcb7.jpeg@f_auto.webp)

其中ARM、MIPS、RISC-V是基于RISC精简指令集，而X86则是基于CISC复杂指令集。

x86架构是基于8086处理器执行的计算机语言指令集。早期的x86（含x64）是cisc的代表，后来的发展中逐步引入了risc的部分理念，将内部指令的实现大量模块化，准确来说是一个cisc外加risc部分技术的架构。

而arm是risc的典型代表，不过在发展过程中引入了部分复杂指令（完全没有复杂指令的话操作系统跑起来异常艰难），所以arm是一个risc基础外加cisc。^[3]^

在PC端，最主要的就是X86的处理器，而移动端就要属ARM的天下了。在英伟达要收购ARM的消息确认后，基于ARM的CPU设计公司担心未来架构授权问题，开源的RISC-V走向了CPU的舞台，成为了各家IC设计公司的新宠。^[2]^

### X86架构

X86是微处理器执行的计算机语言指令集，指一个Intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。1978年6月8日，Intel 发布了新款16位微处理器 8086，也同时开创了一个新时代：X86架构诞生了。
X86指令集是美国Intel公司为其第一块16位CPU（i8086）专门开发的，美国IBM公司1981年推出的世界第一台PC机中的CPU–i8088（i8086简化版）使用的也是X86指令。

随着CPU技术的不断发展，Intel陆续研制出更新型的i80386、i80486直到今天的 Pentium 4系列，但为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源，所以Intel公司所生产的所有CPU仍然继续使用X86指令集。



### ARM架构

ARM架构是一个32位精简指令集处理器架构，其广泛地使用在许多[嵌入式系统设计](https://www.zhihu.com/search?q=嵌入式系统设计&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1622380842})。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。

如今，ARM家族占了所有32位[嵌入式处理器](https://www.zhihu.com/search?q=嵌入式处理器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1622380842})75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置到电脑外设甚至在导弹的弹载计算机等军用设施中都有它的存在。

ARM和X86架构最显著的差别是使用的指令集不同。

![v2-65854b2bb90d6bbee73ade08d901fc92_1440w](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/v2-65854b2bb90d6bbee73ade08d901fc92_1440w.webp)

### RISC-V 

RISC-V 架构是基于 **精简指令集计算**（RISC）原理建立的开放 **指令集架构**（ISA），RISC-V是在指令集不断发展和成熟的基础上建立的全新指令。RISC-V 指令集完全开源，设计简单，易于移植Unix系统，模块化设计，完整工具链，同时有大量的开源实现和流片案例，得到很多芯片公司的认可。

RISC-V 架构的起步相对较晚，但发展很快。它可以根据具体场景选择适合指令集的指令集架构。基于RISC-V 指令集架构可以设计服务器CPU，家用电器CPU，工控CPU和用在比指头小的传感器中的CPU。

### MIPS架构

MIPS架构是一种采取精简指令集（RISC）的处理器架构，1981年出现，由MIPS科技公司开发并授权，它是基于一种固定长度的定期编码指令集，并采用导入/存储（Load/Store）数据模型。经改进，这种架构可支持高级语言的优化执行。其算术和逻辑运算采用三个操作数的形式，允许编译器优化复杂的表达式。

如今基于该架构的芯片广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。最早的MIPS架构是32位，最新的版本已经变成64位。



## 微架构

计算机架构(Computer Architecture)主要指的是指令集架构(Instruction Set Architecture)，而微架构(Micro Architecture)指的是集成电层面的架构。前者主要为编译器和软件开发服务，后者负责具体的硬件实现。

使用不同微架构的电脑可以共享一种指令集。例如，Intel的Pentium和AMD的AMD Athlon，两者几乎采用相同版本的x86指令集体系，但是两者在内部设计上有本质的区别。

**微架构**（英语：microarchitecture），也被叫做**计算机组织**，微架构使得指令集架构（ISA）可以在处理器上被执行。指令集架构可以在不同的微架构上执行。^[5]^

下图为[Intel 80286]的微架构图:

![1920px-Intel_i80286_arch.svg](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/1920px-Intel_i80286_arch.svg.png)



在PC端上，市面上典型的微架构生产公司有Intel与AMD，Intel公司在售的主流处理器系列有Core，Pentium, Celeron等系列^[6]^，而AMD则有K系列与Zen系列等，都是基于X86指令集架构且属于CISC。

![image-20220929200840781](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20220929200840781.png)

而在移动端与嵌入式上，则几乎是ARM指令集架构的天下。

### AMD

如图为AMD CPU的处理器列表，其中，可以看到AMD公司基于ARM指令集架构下的微架构仅有K12，而AMD公司主打的Zen系列则是基于X86-64指令集架构的微架构。

![image-20220929195911306](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20220929195911306.png)

### Intel

一开始Intel公司便在X86指令集架构上陆续开发，由于生态的原因即为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源，所以Intel公司所生产的所有CPU仍然继续使用X86指令集。下图为Intel公司的处理器情况表。

![image-20220929200224505](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20220929200224505.png)

### ARM

ARM是Advanced RISC Machine的缩写，即进阶精简指令集机器。arm更早称为Acorn RISC Machine，是一个32位精简指令集（RISC）处理器架构。也有基于ARM设计的派生产品，主要产品包括Marvell的XScale架构和和德州仪器的OMAP系列。ARM家族中32位嵌入式处理器占比达75%，由于ARM的低功耗特性，被广泛反应于移动通信领域、便携式设备等领域。^[8]^

1983年Acorn电脑公司（Acorn Computers Ltd）开始开发一颗主要用于路由器的Conexant ARM处理器，由Roger Wilson和Steve Furber带领团队，着手开发一种新架构，类似进阶的MOS Technology 6502处理器。Acorn有一大堆建构在6502架构上的电脑。该团队在1985年时开发出ARM1 Sample版，并于次年量产了ARM2，ARM2具有32位的数据总线、26位的寻址空间，并提供64 Mbyte的寻址范围与16个32-bit的暂存器。

在1980年代晚期，苹果电脑开始与Acorn合作开发新版的ARM核心。1990年将设计团队另组成一间名为安谋国际科技（Advanced RISC Machines Ltd.）的新公司,。1991年首版ARM6出样，然后苹果电脑使用ARM6架构的ARM 610来当作他们Apple Newton PDA的基础。在1994年，Acorn使用ARM 610做为他们Risc PC电脑内的CPU。

ARM是一家微处理器行业的知名企业，该企业设计了大量高性能、廉价、耗能低的RISC （精简指令集）处理器，它只设计芯片而不生产。ARM的经营模式在于出售其知识产权核（IP core），将技术授权给世界上许多著名的半导体、软件和OEM厂商，并提供技术服务。

ARM的版本分为两类，一个是内核版本，一个处理器版本。内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是我们通常意义上所指的ARM版本。

ARM版本信息简化表如下表所示。

详细的ARM微架构发展见[维基百科 List of ARM processors](https://en.wikipedia.org/wiki/List_of_ARM_processors)

![image-20220929202309727](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20220929202309727.png)

#### ARM7系列

该系列主要针对某些简单的32位设备，作为目前较旧的一个系列，ARM7处理器已经不建议继续在新品中使用。主要包括ARM7TDMI-S（ARMv4T架构）和ARM7EJ-S（ARMv5TEJ架构）。

#### ARM9系列

主要针对嵌入式实时应用，主要包括ARM926EJ-S、ARM946E-S和 ARM968E-S。

#### ARM11系列

主要应用在高可靠性和实时嵌入式应用领域，主要包括ARM11MPCore、ARM1176、ARM1156、ARM1136。    

####  Cortex-R系列

Cortex-R，代表实时的意义（Real-Time），目标是实时任务处理，主要应用领域包括汽车、相机、工业、医学等。

该系列处理器主要包括Cortex-R4、Cortex-R5、Cortex-R7、Cortex-R8、Cortex-R52、Cortex-A17。

#### Cortex-M系列

Cortex-M，代表微处理器的意义（Microcontrollers），目标是最节能的嵌入式设备，主要应用领域包括汽车、能源网、医学、嵌入式、智能卡、智能设备。传感器融合、穿戴设备等。

该系列处理器主要包括Cortex-M0、Cortex-M0+、Cortex-M3、Cortex-M4、Cortex-M7、Cortex-M23、Cortex-M33、Cortex-M35P。

#### Cortex-A系列

Cortex-A，代表的是先进意义（Advanced），目标是以最佳功耗实现最高性能，主要应用领域包括汽车、工业、医学、调制解调器、存储等。Cortex-A也是目前应用最广的处理器版本。

Cortex-A处理器从高到低可排序为：Cortex-A73、Cortex-A72、Cortex-A57、Cortex-A53、Cortex-A35、Cortex-A32、Cortex-A17、Cortex-A15、Cortex-A7、Cortex-A9、Cortex-A8、Cortex-A5。

目前国产的CPU以及华为的手机麒麟手机芯片和海思芯片等都是基于ARM V8架构的，也是cortex-A系列。可以说在移动便携式领域设备，ARM几乎全部覆盖。



## Apple Silicon芯片家族

除了ARM公司基于ARM内核架构版本设计的微架构，还有其他的公司基于ARM内核版本开发设计自己的微架构，其中较为著名的是Apple公司也基于ARM指令集架构开发设计自己的微架构，在开发的微架构基础上，进而进行芯片设计或封装设计从而推出的“Apple Silicon”芯片家族。

**Apple 芯片**是一系列由 Apple Inc. 设计的芯片系统 (SoC) 和封装系统 (SiP) 处理器，其中应用于iphone上的A系列芯片，是iphone高性能以及畅销的主要原因，在2020年，基于Apple Silicon芯片家族的生态系统，Apple推出了是适用于PC端的M系列芯片，实现了ipad，iphone，macbook三端的ARM指令集架构大一统，对软件开发而言，可以很省心的移植应用。

下图是Apple公司的Apple Silicon芯片家族：

![image-20220930101856966](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20220930101856966.png)

其中A系列最为著名，应用于iphone以及ipad端，“A”系列（适用于*苹果*）是iPhone、某些iPad机型和Apple TV中使用的SoC系列。“A”系列芯片也用于停产的iPod Touch系列和原始HomePod。它们集成了一个或多个基于ARM的处理核心（CPU）、图形处理单元（GPU）、缓存内存和其他必要的电子设备，以便在单个物理包中提供移动计算功能。

H系列应用于AirPods，AirPods Pro，AirPods Max等耳机系列产品，Apple“H”系列（适用于*耳机*）是SoC系列，具有低功耗音频处理和无线连接，可用于耳机。

M系列为应用在Mac端即PC设备上的自研芯片，也应用于ipad端，Apple“M”系列（适用于*Mac*）是2020年11月或之后用于Mac计算机的芯片系统（SoC）系列，2021年4月或之后用于iPad Pro平板电脑，以及2022年3月或更新机型用于iPad Air平板电脑。

S系列应用在Apple Watch 系列上，即穿戴电子表设备端，Apple "S" 系列是Apple Watch 中使用的一系列系统包装 (SiP)。它使用定制的应用程序处理器，与用于无线连接的内存、存储和支持处理器、传感器和I/O一起在单个软件包中形成一台完整的计算机。它们由苹果设计，并由三星等合同制造商制造。

T系列是一个安全芯片，主要功能是应用在处理与加密生物识别信息等，自2016年以来，T系列芯片在基于英特尔的MacBook和iMac计算机上作为安全飞地运行。该芯片处理和加密生物识别信息（触控 ID），并充当麦克风和FaceTime高清摄像头的看门人，保护它们免受黑客攻击。该芯片运行bridgeOS，据称是watchOS的变体。T系列处理器的功能内置在M系列CPU中，从而结束了对T系列的需求。

U系列则是应用在无线充电以及无线充电盒的控制芯片，Apple“U”系列是实现超宽带（UWB）无线电的软件包（SiP）中的一系列系统。

W系列一开始的W1应用于初代Airpods用于保持蓝牙连接以及解码音频流，而后耳机系列使用H系列的芯片，从W2开始之后W系列主要应用在Watch系列，集成到了S系列的芯片中，该系列芯片使得WiFi速度提高，并用于蓝牙连接，Apple“W”系列（用于*无线*）是一系列用于蓝牙和Wi-Fi连接的RF SoC。





## M1芯片

了解完指令集架构，微架构以及Apple Silicon芯片家族的细节之后，我们分别从指令集架构角度以及微架构角度来看Apple在2020年新推出的M系列芯片M1。

### 指令集架构

从指令集架构上，M1 实现的是 ARMv8-A 指令集。2011年10月，Armv8-A代表了ARM架构的根本性变化横空出世。它添加了一个可选的64位架构，名为“AArch64”，以及相关的新“A64”指令集。AArch64提供了与Armv7-A（32位架构）的用户空间兼容性，其中称为“AArch32”和旧的32位指令集（现在称为“A32”）。Thumb指令集被称为“T32”，没有64位对应指令。Armv8-A允许32位应用程序在64位操作系统中执行，32位操作系统由64位虚拟机管理程序控制。ARM于2012年10月30日宣布了他们的Cortex-A53和Cortex-A57内核。苹果是第一个在消费品中发布Armv8-A兼容核心的（iPhone 5S中的Apple A7）。

当然，随着ARMv8-A系列的升级，Apple A7到Apple A10X都是基于初代的ARMv8-A，而Apple A11是基于ARMv8.2-A，Apple A12，A12X以及A12Z基于ARMv8.3-A，A13基于ARMv8.4-A，A14，A15，A16以及M1与新发布的M2则是ARMv8.5-A。

大体上，从2012-2022年，Apple在A系列以及M系列上采用的指令集架构都是64位系统的ARMv8-A。

当然，由于功耗低等优势问题，基于RISC的ARM指令集架构占据了移动端与嵌入式的市场，而在PC端，很长的一段时间，Intel与AMD的X86指令集桌面级处理器是PC端的主流，那么为什么在Apple发布M1芯片之前，我们鲜少能在市面上看到优秀的ARM类的桌面级处理器呢？

其实并不是没有出现，只是软件兼容性太差，早在2012年的时候，微软就发布了第一代的原生Windows 操作系统——Windows RT，并将其用在了初代Surface平板上，这台平板搭载了英伟达Tegra 3 SoC，基于ARM架构，这便是这一切的鼻祖。但是在当时，这款电脑的评价并不好，因为它性能太差，而且当时的Windows RT受限于ARM兼容性，几乎什么都运行不了，所以很快它就沉沦了。

所以其实在ARM架构上的PC不是没有可能，而是基于ARM的软件兼容性，以及操作系统的问题，而Apple公司拥有自己的Mac OS生态，以及强大的号召力，让各大软件厂商开始正对ARM架构的系统进行软件的适配。因此从M1发布之后，以及随着时间的流逝，各大厂商纷纷对ARM系统进行软件适配之后，基于ARM架构的PC由于功耗低，续航好的先天优势，在获得生态与软件上的支持后，或许也能在如今的X86占主流的桌面端市场上分到一份蛋糕。



### 微架构

其实对于Arm指令集的应用于PC端的微架构，并不是没有公司研究过，2019年10月2日微软发布的的surface pro x便是arm指令集的pc，却由于是arm架构的且微软没有做出合适的转译办法，导致很长一段时间，surface pro x并不能兼容运行64位的X86软件，有着极其糟糕的生态与体验，也就是在2020年M1发布的前几天才刚刚兼容 64 位的X86 软件，且依然有着许多限制， 微软和高通的合作定制的这款用着 A76 微架构的SQ1处理器，虽然具备了传统笔记本所不具备的高续航、永远在线等诸多新特性。但是这个处理器的性能也实在是谈不上优秀。在处理器天梯图里它甚至还赶不上 2018 年推出的苹果 A12 X。

而苹果的M1芯片却有着高性能与超高规格的微架构，M1是一个超高规格版的A14，与A14一样，M1 的大核是 Firestorm，小核是 Icestorm，但是不同的是，M1有4个大核4个小核以及8核的GPU，当然作为电脑处理器，M1的频率相应有所提升。

由图可见，大核 Firestorm的核心IPC 大约是 SQ1 里面的 A76 大核的两倍，而小核的 IPC 则与之相仿，达成这种性能的关键就在于它恐怖的架构规模。

![image-20220930122354419](/Users/zhanghaha/Library/Application Support/typora-user-images/image-20220930122354419.png)





## M1的架构规模与并行分析

我们使用基于X86架构的AMD的Zen3，以及Intel的Skylake微架构与Apple的M1的大核Firestorm进行架构对比，如图：

![image-20220930122503540](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20220930122503540.png)

乍一看这三个的架构图都长得很像，因为不管是什么架构的 CPU ，他们的工作流程大体都是相同的，都是==流水线==形式的工作流程，要经过这五个阶段，分别是：取指令（IF｜Instruction Fetch），指令译码（ID｜Instruction Decode），执行指令（EXE｜Execute），访存取数（MEM｜Memory），结果写回（WB｜Writeback），所以他们的架构按着这五个运行阶段流程来设计的话，整体上可以看到的架构也是大同小异。

那这三种架构本质上都是==乱序执行，超标量，多流水线的CPU。==

我们可以按照处理器的工作步骤一点点来对比他们的架构。

### IF（取指令）

在该阶段非常重要的是L1 指令缓存，也就是暂时储存CPU指令的缓存。

从上图可以看出，对于L1-1，M1有192KB而Zen3 和Skylake都只有32KB。

处理器想要执行指令，就得先从一个地方加载指令。而 L1 指令缓存就是用来暂时保存这些指令以备后用的。从M1的L1-1缓存的大小可以看出，M1在 JS 之类的高指令压力负载下，其表现较另外两个32KB的会非常好，同时这个大小的差别预示着 M1可能是个非常宽的架构。

### ID（指令译码）

指令解码器是用于将输入指令解码CPU为可执行指令的单元。即CPU拿到指令后，其内部的执行单元其实看不懂从内存中取出的指令。因为 CPU 内部有它自己的指令编码，所以咱们要对指令进行解码，把来自软件的指令翻译成 CPU 认识的指令。

在这个部分，有一个很重要的问题，也就是区分ARM架构与X86架构CPU的关键之处：就是关于 RICS 和 CISC这两个指令集架构的处理器的区别。 RISC处理器是指精简指令集处理器（Reduced Instruction Set Computer）， ARM 就属于此类，而 CISC是指复杂指令集（Complex Instruction Set Computer），X86 就是此类的代表。

两者的界定是输入指令是复杂指令的就是CISC，输入指令为精简指令的就是RISC，CISC有着复杂指令，结构复杂，种类繁多，长短不一，执行时间不恒定的特点，而RISC则有着精简指令，结构简单，种类精简，长短划一，执行时间恒定的特点。那么这是不是意味着RISC就会更快更简单呢？并不是如此。

现代的 RISC 处理器和 CISC 处理器最大的区别在于指令解码环节。

作为现代CISC处理器的代表，X86 接受的是 CISC 指令，但其实从Intel的奔腾 PRO 开始，处理器内部执行的其实已经是类RISC 指令了。也就是X86 处理器会通过解码器把这些复杂的指令（CISC）翻译成类似RISC的指令。

![image-20221003211655278](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20221003211655278.png)

Intel把这些类RISC指令称作 Micro-Op。

而AMD 从 K5 开始也引入了自己的类RISC指令集，叫做RISC86，也就是Macro-Op然后再翻译成Micro-Op，一条Macro-Op可以翻译成一个或多个Micro-Op。

因此Intel与AMD的CPU解码设计上会有所差别。

由于这些差别，Intel需要 N 个简单解码器加一个复杂解码器，而 AMD 则有N个解码器就可以了。

比如此处的Zen3需要4个解码器，而Skylake需要4个简单解码器与一个复杂解码器。

解码器的效率直接决定了后面的执行单元有多少活可以去做。

那么问题来了，M1基于ARM处理器，而ARM处理器基于RISC指令集架构，为啥CPU还需要解码器呢？实际上 RISC处理器接受的指令和执行单元执行的指令虽然差别很小，但依然有区别，所以也需要解码器来翻译。但显然这个解码工作简单得多，这就是ARM处理器能耗比优势的一个重要因素。

也就是对于X86与ARM架构的电脑来说，执行单元内部执行的其实都是类RISC指令，也就是说经过解码阶段后，X86与ARM架构的CPU所要做的事情便趋近于一致。那么由此看来，基于不同指令集的处理器，最重要的区别便是X86接受的CISC指令在解码转化为类RISC命令时，解码器所做的工作量更大，能耗也更大，这么看来，基于CISC的ARM指令集架构在解码阶段有着先天的优势。

在解码工作量较X86更小的情况下，Apple却在M1的大核心微架构Firestorm里面塞入了每周期解码 8 个指令的解码器，这个应该是目前处理器里规格里最大的解码器。

简单总结一下，现代的X86 处理器和ARM处理器在经过解码阶段后，内部都会执行类RISC指令，因而接下来的运行阶段是高度类似的。而在解码部分，M1具有ARM的先天优势，解码前后差异小，效率更高，同时解码器又做得更宽，所以有了更高的性能。

### EXE（执行指令）

现代的应用于桌面端移动端的处理器，其架构大多具有乱序执行，超标量，多流水线的特性，这便是并行中很关键的特点。我们分析的三种处理器都是具有并行特性的。

#### 多发射

AMD 的X86处理器实际执行的是Macro-Ops，而Zen3每个周期可以发射6个Macro-Ops指令，于是我们就认为Zen3是一颗 6 发射的处理器。而这个指令发射数是目前X86处理器里最高的，再加上Zen3优秀的分支预测，消除了大部分的气泡，使得它达到了X86 阵营目前的最高效率。

而对比Intel的X86处理器，其实际执行的是Micro-Ops，Skylake每个周期可以发射4个Micro-Ops指令。

![image-20221003215737423](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20221003215737423.png)

对于Zen3而言，其有4个解码器，每个周期可以发射6个Macro-Ops指令，Skylake有4个简单解码器与1个复杂解码器即一共5个解码器，每个周期可以发射4个Micro-Ops指令，而对M1来说，其接收到的每一条指令将会转换，且仅会转换为一条指令，所以解码器的宽度就等于发射数。于是Apple制造了一个惊人的 8 发射处理器核心。作为对比，同为ARM架构的移动端处理器骁龙888的Cortex-X1是一个五发射处理器核心。

#### ROB（重排序缓冲区）

ROB（重排序缓冲区）对乱序执行的处理器而言至关重要。多发射的处理器每个周期会解码出多条的指令，对于没有依赖关系的指令，乱序执行的处理器可以在保证结果正确的情况下重新排列指令的顺序，让这些没有依赖关系的指令可以不用等待前面的指令执行完成就去执行。但乱序执行后的结果需要按原有顺序排好序才算执行完成。而ROB所做的事情就是将乱序执行后的结果进行排序。

ROB里面保存着指令原有的顺序，经过乱序执行的指令，在执行完成之后，再按照ROB当中所存储的顺序写入寄存器，这样才算指令执行完毕。

所以往往ROB越大，意味着处理器的宽度越大且乱序度越高。M1大概有 630 个条目的 ROB 作为对比，Zen3有 256 个，Intel的Skylake有 224个，Sunny Cove的Ice Lake有352个，而ARM的Cortex-X1有 224 个。

可以看出，M1的处理器比起其他的处理器儿而言，其处理器的宽度非常大且乱序度很高。

### 执行单元（MEM&WB）

CPU中的执行单元有两种，整数执行单元ALU（算术逻辑单元）与浮点执行单元FPU（浮点单元）。我们重点关注浮点执行单元。

#### SIMD

当你需要对多个元素执行相同的操作时，SIMD（单指令流多数据流）是一种获得更高性能的方法。这与矩阵运算密切相关。实际上，SIMD指令通常用于加速矩阵乘法。SIMD向量引擎是微处理器内核的一部分。在微处理器内部有一个指令解码器，它将对一条指令进行拆分，并决定激活什么功能单元。

X86 CPU 里有一个SIMD指令集叫做高级向量扩展指令集（Advanced Vector Extensions）即AVX，是X86架构微处理器中的指令集，由英特尔在2008年3月提出。AVX是在之前的128位扩展到256位的单指令多数据流。它解决了X86系列CPU在decoding上的不足。

X86 CPU 的AVX性能在如今十分重要。曾经Zen2相较于Zen或者Zen+的巨大提升，很大程度就来源于AVX性能的提升。AVX作为SIMD（单指令流多数据流）指令集，十分依赖SIMD的宽度。而在ARM架构中有一种类似于 AVX的指令集叫做 Neon。Neon也是SIMD指令集。

![image-20221003224115984](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20221003224115984.png)

M1的每个核心里有四个128 位的引通道。这个规格和 Skylake 以及 Zen3 是同一水平。至少在处理器的架构层面上，这颗 ARM处理器的浮点性能就已经站上了和X86 最先进的架构平等的水平。

在CPU内部，会有ALU、FPU以及SIMD向量引擎，作为独立的部分，由指令解码器激活。而协处理器则是外置在微处理器内核上的。比如英特尔8087，这是最早的协处理器芯片之一，它是一种物理上独立的芯片，旨在加快浮点计算的速度。 M1 有一个Apple独家的能够协同浮点单元和 NPU 计算的AMX（矩阵协处理器）指令集，这让它的浮点性能更上一层楼，但浮点性能的发挥还和频率以及内存性能有关。

#### 内存性能

接下来我们将分析M1 的缓存与内存设计。缓存对于 CPU 的 PPC 有着巨大的帮助。Zen2 的桌面版和移动版的差距就是由于 L3 缓存导致的；COVES的两个架构Ice Lake与改进版Tiger Lake更是几乎只有缓存容量上的区别。Apple在 M1 的大核里塞进了 12 MB的共享二级缓存。作为对比， A14 里面的大核的二级缓存是 8 MB，这个 12 MB的二级缓存应该是现代 CPU 里最大的二级缓存设计，平均每核心 3 MB的二级缓存远大于Tiger Lake或者是Zen3的二级缓存，更接近它们的三级缓存。在Apple以外的 CPU 上，见到这样的大二级缓存还是在酷睿 2 时代。

 M1 的小核心则配置了 4 MB的二级缓存，这个大小就更接近我们认知中的二级缓存。

一般来说，二级缓存的容量越大，延迟就越难优化。但就容量来看， M1 的规格确实有点吓人。

![image-20221004085236261](/Users/zhanghaha/Library/Application Support/typora-user-images/image-20221004085236261.png)除此之外， M1 还有一个类似三级缓存的系统级别缓存，这个缓存是 CPU，GPU，NPU 等等单元共享的。从官方的 keynote公布的 DIE Shot 来看，这个系统级别缓存的部分应该和 A14一样都是 16 MB，因为 GPU 也要用到这个缓存，所以 CPU 的大二级缓存应该也和这一点有关系。

在内存方面， M1 配备了Apple称之为统一内存架构的内存。实际上这并不是Apple第一次这样做，在iPad pro的 A12X以及A12Z，便已经应用了统一内存架构的内存。

![image-20221004090033186](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20221004090033186.png)这次的M1，同样利用了统一内存架构，那 M1 集成在片上的内存是双通道的 LPDDR4X 4266，这里所说的双通道指的是 128 位，而不是手机上常说的 64 位，也就是说它的带宽相比 A14 是翻番的和内存配置比较好的Intel或者AMD的核显笔记本带宽近似。

计算机里有一个常识，距离越近延迟就越低。所以Apple这个统一内存架构的操作应该主要是为了降低延迟以及更好保证 GPU 的性能表现。

## 处理器设计平衡



![image-20221004090538054](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20221004090538054.png)

简单总结一下M1的架构，这应该是目前最超大杯的处理器核心，即使和Zen3和Skylake相比依然十分巨大，加上使用了目前桌面级 CPU 唯一的 5 纳米工艺，这颗处理器的性能表现十分优秀。

其实这么分析下来，基于AMD的X86 Zen3 架构也非常优秀，似乎只是规格不如 M1 那么好，也许再做宽一点就能在 IPC 上打败 M1 了。可问题是，为什么其他厂商不去做像 M1 处理器一样宽的架构来提升 IPC 呢？这其实包含着几个方面的原因。

### 成本

第一，Apple的处理器不外卖，他卖的是笔记本、平板和手机，但其他处理器厂商卖的是处理器。不论是高通还是英特尔还是 AMD，这些公司赚取的是处理器那部分的利润，而Apple就可以省出这部分利润用来继续堆规格，但整机的成本却不会上涨。甚至因为 Mac 设备共享处理器架构，处理器的研发成本还可以得到 iPhone 和 iPad 的分摊。于是在处理器制造成本可能比英特尔或者说 AMD 更高的情况下，Apple赚的反而更多了。

### 兼容性换性能

第二，Apple在A11 的时代就在硬件层面终结了对 32 位应用的支持，而macOS也在去年的10.15版本里就去掉了对32位应用的支持。到如今Apple已经完成了全 64 位软件的准备。但是X86架构却无法脱离曾经的32位软件的捆绑，你是否能想象买回家的Zen3处理器完全不支持 32 位应用，如果真的这样，那么许多应用便完全不能使用。但Apple对生态的控制使得他们可以用一定的兼容性去换取更强的性能。而X86就得背着这种具有数十年历史的“X86税”，在增加性能的同时继续保持对上古软件的兼容，但这种兼容性也是要占面积和费电的。

### 利于提高能耗比

第三， M1参考并在A14的基础上进行提升改进，而A14 来自于手机，这意味着它要用更高的 IPC 去换取更低的频率和电压，这样才能够保证移动设备的续航。那对于 AMD 和英特尔来说，应用他们处理器的最低功耗设备是笔记本，而更高功耗的台式机并不需要考虑续航问题，所以他们可以用相对更高的频率获取相同的性能。虽然此时的能耗比会有所下降，但绝对性能上 4.5GHz- 5GHz的Zen3也绝不会低于 3.2GHz的M1。可以说 M1 虽然是同频的性能之王，但未必是同面积性能之王。面积就是制造成本，这对于双核或者四核来说可能不会差那么大。但如果是 16 个甚至是 64 个核，处理器厂商的一个架构是要覆盖笔记本到服务器的，那么这件事就不得不考虑了。

### 处理器的设计

处理器的设计无非就是平衡功耗、性能和成本，功耗会因为频率和电压而大幅上升，成本会由于利润率的要求尽可能压低，所以反映在性能上就得找到一个平衡点。Apple的特别之处就在于有着强大的生态，对于功耗，性能与成本这三点，它都有着绝对的控制权，于是就可以找到一个相对高的平衡点。因此如此高规模的宽架构的M1就因此诞生了。

## 架构的过渡

苹果宣布彻底放弃使用X86架构的Intel芯片，而是在Mac上搭载自己的基于ARM架构开发的芯片M1，由于 M1 芯片底层架构和过去不同，由此带来的应用生态兼容性问题是首先需要解决的，为此苹果也开启了为期两年的 Mac 过渡计划。具体来说，苹果借助的是 macOS 11 Big Sur 系统以及其内置的 Universal 2、Rosetta 2 和 Virtualizaion 三种技术来解决问题。

Rosetta 2是 M1 Mac 的一个杀手锏。但是事实上Apple不是第一次做处理器架构间的转换工具了。早在2006年，第一代Rosetta正是Mac从Power PC转向Intel架构时苹果推出的架构转换工具，当时是从ARM架构转换成X86。

![image-20221004092917923](https://zyzstc-1303973796.cos.ap-beijing.myqcloud.com/uPic/image-20221004092917923.png)

而这次的Rosetta 2是Apple从X86架构重新过渡回ARM架构的转换器。首先它的兼容性确实不错，不像Microsoft姗姗来迟的为自己推出的令人诟病的无法兼容X86软件的ARM架构的设备的X86-64支持，Apple的Rosetta 2，从一开始就可以运行X86-64位应用，且兼容性确实不错。基本上老 Mac 用户可以直接用恢复他们的备份到 M1 的 Mac，且绝大多数的软件运行都没啥问题。

但作为一个转译器，除了要保证兼容性，性能表现也十分重要。ARM和X86 的内存一致性模型不同，这会导致多线程软件运行的问题。苹果在 M1 里直接做了两版内存模型，在运行原生应用的时候，使用 ARM的那套内存模型，而在运行X86 转译应用的时候，就切换到X86 的那套内存模型，这种软硬件结合带来了Rosetta 2的优秀表现。Rosetta 2不仅是一个软件层面的转译器，更是需要配合Apple的处理器设计才实现了如今的表现。

此外，Rosetta 2 并不是一个动态转译器，而是一个静态转译器。Rosetta 2并不是等到应用开启使用时，才一条指令一条指令地去翻译，而是在应用安装时就会对应用进行翻译，在用户使用应用前就给到一个针对 ARM 平台优化的版本。对于那些无法提前翻译的指令，才会在使用时候进行即时的翻译，在首次打开X86 应用时，它会帮你默默转换完你的软件。然后之后打开的时候就会直接打开翻译后的代码。形象点说，动态翻译器就像是同声传译，而静态翻译就像是看翻译完的文章。这样一来性能损失会更小，也更容易保持软件的稳定。

基于这样的机制，Rosetta 2 能够帮助 X86 架构的应用在 M1 芯片的 Mac 上保持流畅快速的响应，从而获得很好的使用体验。当然，Rosetta 2 做翻译的方案毕竟只是权宜之计，不会一直存在，只是在开发者们将自己的应用全面转到 M1 芯片原生状态之前扮演过渡的作用。



参考：

1. https://baike.baidu.com/item/指令集/238130
2. https://www.zhihu.com/question/423489755/answer/1622380842
3. https://blog.csdn.net/leftfist/article/details/122488559
4. https://zh.wikipedia.org/wiki/指令集架構#指令集的分类
5. https://zh.wikipedia.org/wiki/微架構
6. https://ark.intel.com/content/www/us/en/ark.html#@Processors
7. https://blog.csdn.net/dunwin/article/details/84253928
8. https://blog.csdn.net/qq_34160841/article/details/105611131
9. https://en.wikipedia.org/wiki/List_of_ARM_processors
10. https://en.wikipedia.org/wiki/ARM_architecture_family#64/32-bit_architecture
11. https://en.wikipedia.org/wiki/Apple_M1
12. https://en.wikipedia.org/wiki/Apple_silicon
13. https://zhuanlan.zhihu.com/p/351072166
14. https://www.bilibili.com/video/BV1Mo4y1Z7jb/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8db43b9c09e21e53f4e4e098be322d11